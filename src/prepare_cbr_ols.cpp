// feature values for the final street are ordered numerically by the
// hole cards: 22, 32, etc.
// The CBRs are ordered by hand strength on the final street.

#include <math.h>
#include <stdio.h>
#include <stdlib.h>

#include <string>

#include "betting_abstraction.h"
#include "betting_abstraction_params.h"
#include "betting_tree.h"
#include "board_tree.h"
#include "canonical_cards.h"
#include "card_abstraction.h"
#include "card_abstraction_params.h"
#include "cfr_config.h"
#include "cfr_params.h"
#include "files.h"
#include "game.h"
#include "game_params.h"
#include "hand_tree.h"
#include "io.h"
#include "params.h"
#include "rgbr.h"

using namespace std;

class Walker {
public:
  Walker(const CardAbstraction &card_abstraction,
	 const BettingAbstraction &betting_abstraction,
	 const CFRConfig &cfr_config, const string &features, unsigned int st,
	 unsigned int it, unsigned int p);
  ~Walker(void);
  void Go(void);
private:
  double *LoadCVs(Node *node, unsigned int bd);
  void Walk(Node *node, int last_st);
  
  const CardAbstraction &card_abstraction_;
  const BettingAbstraction &betting_abstraction_;
  const CFRConfig &cfr_config_;
  unsigned int st_;
  unsigned int it_;
  unsigned int p_;
  BettingTree *betting_tree_;
  unsigned int num_features_;
  short *feature_vals_;
  Writer *x_writer_;
  Writer *y_writer_;
};

Walker::Walker(const CardAbstraction &card_abstraction,
	       const BettingAbstraction &betting_abstraction,
	       const CFRConfig &cfr_config, const string &features,
	       unsigned int st, unsigned int it, unsigned int p) :
  card_abstraction_(card_abstraction),
  betting_abstraction_(betting_abstraction), cfr_config_(cfr_config) {
  st_ = st;
  it_ = it;
  p_ = p;
  BoardTree::Create();
  betting_tree_ = BettingTree::BuildTree(betting_abstraction_);
  unsigned int num_boards = BoardTree::NumBoards(st);
  unsigned int num_hole_card_pairs = Game::NumHoleCardPairs(st);
  unsigned int num_hands = num_boards * num_hole_card_pairs;
  char buf[500];
  sprintf(buf, "%s/features.%s.%s.%u", Files::StaticBase(),
	  Game::GameName().c_str(), features.c_str(), st_);
  Reader reader(buf);
  num_features_ = reader.ReadUnsignedIntOrDie();
  unsigned int num = num_hands * num_features_;
  feature_vals_ = new short[num];
  unsigned int max_street = Game::MaxStreet();
  if (st_ == max_street) {
    // Need to reorder on the final street.  The feature values are ordered
    // "numerically" by hole card pair.  But the CBR values are ordered by
    // hand strength.
    HandTree hand_tree(0, 0, max_street);
    unsigned int num_boards = BoardTree::NumBoards(st_);
    unsigned int max_card1 = Game::MaxCard() + 1;
    unsigned int num_enc = max_card1 * max_card1;
    short *old_feature_vals = new short[num_enc * num_features_];
    for (unsigned int bd = 0; bd < num_boards; ++bd) {
      fprintf(stderr, "bd %u\n", bd);
      const CanonicalCards *hands = hand_tree.Hands(max_street, bd);
      const Card *board = BoardTree::Board(max_street, bd);
      unsigned int num_board_cards = Game::NumBoardCards(max_street);
      unsigned int i = 0;
      for (Card hi = 1; hi < max_card1; ++hi) {
	if (InCards(hi, board, num_board_cards)) continue;
	for (Card lo = 0; lo < hi; ++lo) {
	  unsigned int enc = hi * max_card1 + lo;
	  for (unsigned int f = 0; f < num_features_; ++f) {
	    old_feature_vals[enc * num_features_ + f] =
	      reader.ReadShortOrDie();
	  }
	  ++i;
	}
      }
      for (unsigned int i = 0; i < num_hole_card_pairs; ++i) {
	const Card *hole_cards = hands->Cards(i);
	unsigned int enc = hole_cards[0] * max_card1 + hole_cards[1];
	unsigned int h = bd * num_hole_card_pairs + i;
	for (unsigned int f = 0; f < num_features_; ++f) {
	  feature_vals_[h * num_features_ + f] =
	    old_feature_vals[enc * num_features_ + f];
	}
      }
    }
    delete [] old_feature_vals;
  } else {
    for (unsigned int i = 0; i < num; ++i) {
      feature_vals_[i] = reader.ReadShortOrDie();
    }
  }

  char dir[500];
  sprintf(dir, "%s/%s.%s.%i.%i.%i.%s.%s", Files::NewCFRBase(),
	  Game::GameName().c_str(),
	  card_abstraction_.CardAbstractionName().c_str(), Game::NumRanks(),
	  Game::NumSuits(), Game::MaxStreet(),
	  betting_abstraction_.BettingAbstractionName().c_str(), 
	  cfr_config_.CFRConfigName().c_str());
  sprintf(buf, "%s/cbr_xs.%u.%u.%u", dir, st_, p_, it_);
  x_writer_ = new Writer(buf);
  sprintf(buf, "%s/cbr_ys.%u.%u.%u", dir, st_, p_, it_);
  y_writer_ = new Writer(buf);
}

Walker::~Walker(void) {
  delete x_writer_;
  delete y_writer_;
  delete [] feature_vals_;
  delete betting_tree_;
}

double *Walker::LoadCVs(Node *node, unsigned int bd) {
  // Current strategy: use CVs generated by build_prbrs if the base system
  // used any abstraction (including the null abstraction).  Otherwise use
  // CVs generated by build_cbrs.
  bool bucketed = false;
  unsigned int max_street = Game::MaxStreet();
  for (unsigned int st = 0; st <= max_street; ++st) {
    const string &bk = card_abstraction_.Bucketing(st);
    if (bk != "none") {
      bucketed = true;
      break;
    }
  }
  unsigned int st = node->Street();
  unsigned int nt = node->NonterminalID();
  char dir[500], buf[500];
  sprintf(dir, "%s/%s.%s.%i.%i.%i.%s.%s/%s.%u.%s/%u.%u.p%u",
	  Files::NewCFRBase(), Game::GameName().c_str(),
	  card_abstraction_.CardAbstractionName().c_str(),
	  Game::NumRanks(), Game::NumSuits(), Game::MaxStreet(),
	  betting_abstraction_.BettingAbstractionName().c_str(), 
	  cfr_config_.CFRConfigName().c_str(),
	  bucketed ? "prcbrs" : "cbrs", it_, p_ ? "p1" : "p2", nt, st,
	  node->PlayerActing());
  sprintf(buf, "%s/vals.%u", dir, bd);
	  
  Reader reader(buf);
  unsigned int num_hole_card_pairs = Game::NumHoleCardPairs(st);
  double *cvs = new double[num_hole_card_pairs];
  for (unsigned int i = 0; i < num_hole_card_pairs; ++i) {
    cvs[i] = reader.ReadFloatOrDie();
  }
  return cvs;
}

void Walker::Walk(Node *node, int last_st) {
  if (node->Terminal()) return;
  int st = node->Street();
  if (st == (int)st_ && last_st == st - 1) {
    unsigned int num_boards = BoardTree::NumBoards(st_);
    unsigned int num_hole_card_pairs = Game::NumHoleCardPairs(st_);
    for (unsigned int bd = 0; bd < num_boards; ++bd) {
      double *cvs = LoadCVs(node, bd);
      for (unsigned int i = 0; i < num_hole_card_pairs; ++i) {
	y_writer_->WriteDouble(cvs[i]);
	// x_writer_->WriteDouble(node->PotSize());
	// printf("%f", (double)node->PotSize());
	unsigned int h = bd * num_hole_card_pairs + i;
	for (unsigned int f = 0; f < num_features_; ++f) {
	  x_writer_->WriteDouble(feature_vals_[h * num_features_ + f]);
	  printf(" %f", (double)feature_vals_[h * num_features_ + f]);
	}
	printf(" -> %f\n", cvs[i]);
      }
      delete [] cvs;
    }
  }
  unsigned int num_succs = node->NumSuccs();
  for (unsigned int s = 0; s < num_succs; ++s) {
    Walk(node->IthSucc(s), st);
  }
}

void Walker::Go(void) {
  Walk(betting_tree_->Root(), -1);
}

static void Usage(const char *prog_name) {
  fprintf(stderr, "USAGE: %s <game params> <card params> <betting params> "
	  "<CFR params> <it> <st> <p> <features>\n", prog_name);
  exit(-1);
}

int main(int argc, char *argv[]) {
  if (argc != 9) Usage(argv[0]);
  Files::Init();
  unique_ptr<Params> game_params = CreateGameParams();
  game_params->ReadFromFile(argv[1]);
  Game::Initialize(*game_params);
  unique_ptr<Params> card_params = CreateCardAbstractionParams();
  card_params->ReadFromFile(argv[2]);
  unique_ptr<CardAbstraction>
    card_abstraction(new CardAbstraction(*card_params));
  unique_ptr<Params> betting_params = CreateBettingAbstractionParams();
  betting_params->ReadFromFile(argv[3]);
  unique_ptr<BettingAbstraction>
    betting_abstraction(new BettingAbstraction(*betting_params));
  unique_ptr<Params> cfr_params = CreateCFRParams();
  cfr_params->ReadFromFile(argv[4]);
  unique_ptr<CFRConfig> cfr_config(new CFRConfig(*cfr_params));
  unsigned int it, st, p;
  if (sscanf(argv[5], "%u", &it) != 1) Usage(argv[0]);
  if (sscanf(argv[6], "%u", &st) != 1) Usage(argv[0]);
  if (sscanf(argv[7], "%u", &p) != 1) Usage(argv[0]);
  string features = argv[8];
  
  Walker walker(*card_abstraction, *betting_abstraction, *cfr_config,
		features, st, it, p);
  walker.Go();
}
